# 客户端缓存

在 Web 性能优化中，**浏览器缓存**是一项重要技术，它可以减少请求次数，加快页面加载速度。主要有两种缓存策略：

- **强制缓存（强缓存）**（本地缓存，不发送请求）
- **协商缓存**（服务器确认是否使用缓存）

## **1. 强制缓存（强缓存 / 本地缓存）**

**强制缓存**指的是浏览器**直接使用本地缓存**，不会向服务器发送请求。如果缓存有效，则资源从缓存中加载，**减少请求**，提升性能。

### **1.1 强制缓存的实现方式**

主要由 **`Expires`** 和 **`Cache-Control`** 头部控制。

#### **① `Expires`（HTTP/1.0，绝对时间）**

服务器返回 `Expires` 头，指定资源的过期时间：

```http
Expires: Wed, 21 Oct 2025 07:28:00 GMT
```

- **缺点**：依赖客户端的本地时间，如果本地时间错误，可能导致缓存失效。

#### **② `Cache-Control`（HTTP/1.1，相对时间）**

`Cache-Control` 更先进，控制缓存的行为，例如：

```http
Cache-Control: max-age=31536000
```

- `max-age=31536000`：表示资源缓存 **31,536,000 秒（1 年）**，在此期间，浏览器不会向服务器请求资源。
- 其他常见取值：
  - `no-cache`：使用缓存前必须**向服务器验证**（实际还是协商缓存）。
  - `no-store`：**不缓存**，每次都从服务器获取最新数据。
  - `private`：仅**用户本地缓存**，代理服务器不会缓存。
  - `public`：浏览器和代理服务器都可以缓存。

## **2. 协商缓存**

如果**强制缓存失效**（如 `max-age` 过期），浏览器会向服务器发送请求，服务器决定是否让浏览器继续使用缓存，这就是**协商缓存**。

### **2.1 协商缓存的实现方式**

协商缓存由 `ETag` 和 `Last-Modified` 头部控制。

#### **① `Last-Modified` / `If-Modified-Since`（基于时间）**

- **`Last-Modified`**：服务器返回资源最后修改时间：

  ```http
  Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
  ```

- **`If-Modified-Since`**：浏览器下次请求时，带上上次的 `Last-Modified` 值：

  ```http
  If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
  ```

- **服务器处理逻辑**：

  - 如果文件 **未修改**，返回 **`304 Not Modified`**，浏览器继续使用缓存。
  - 如果文件 **已修改**，返回 **新内容（200 OK）**。

- **缺点**：

  - 只能精确到**秒级**，如果文件**秒级内修改多次**，无法检测到。
  - 某些情况下，文件内容未修改，但 `Last-Modified` 可能会变化（如重新部署）。

#### **② `ETag` / `If-None-Match`（基于内容）**

- **`ETag`** 是服务器为资源生成的**唯一标识**（类似哈希值），如：

  ```http
  ETag: "5d8c72a5d73bc1:0"
  ```

- **`If-None-Match`**：浏览器下次请求时，带上上次的 `ETag`：

  ```http
  If-None-Match: "5d8c72a5d73bc1:0"
  ```

- **服务器处理逻辑**：

  - 如果 `ETag` **未变**，返回 **`304 Not Modified`**，浏览器继续使用缓存。
  - 如果 `ETag` **改变**，返回 **新内容（200 OK）**。

- **优点**：

  - 比 `Last-Modified` 更精确，能检测**秒级内的更改**。
  - 适用于内容动态生成的资源，如 HTML、JSON。

## **3. 强制缓存 vs 协商缓存**

| 缓存类型     | 触发条件         | 请求是否发送 | 服务器响应                                                |
| ------------ | ---------------- | ------------ | --------------------------------------------------------- |
| **强制缓存** | `max-age` 未过期 | ❌ 不发送请求 | 直接使用本地缓存                                          |
| **协商缓存** | `max-age` 过期   | ✅ 发送请求   | `304 Not Modified`（继续用缓存）或 `200 OK`（返回新内容） |

## **4. 浏览器缓存策略示例**

服务器返回的响应头：

```http
Cache-Control: max-age=3600  # 强制缓存 1 小时
ETag: "abc123"               # 协商缓存
Last-Modified: Mon, 15 Feb 2024 12:00:00 GMT
```

### **请求 1（初次请求）**

浏览器第一次访问，服务器返回 `200 OK` 和缓存控制信息。

### **请求 2（缓存未过期，强制缓存）**

1. 浏览器**不发送请求**，直接使用本地缓存（`max-age` 还未到）。
2. 状态码：`(from memory cache)` 或 `(from disk cache)`

### **请求 3（缓存过期，协商缓存）**

1. 浏览器发送请求，带上：

   ```http
   If-None-Match: "abc123"
   If-Modified-Since: Mon, 15 Feb 2024 12:00:00 GMT
   ```

2. 服务器检查 ETag 和 Last-Modified：

   - **文件未修改**：返回 `304 Not Modified`，浏览器使用缓存。
   - **文件已修改**：返回 `200 OK`，浏览器获取新内容。

## **5. 结合使用缓存策略**

实际开发中，通常会**结合强制缓存和协商缓存**：

1. **强制缓存 + 协商缓存**

   ```http
   Cache-Control: max-age=31536000, public
   ETag: "abc123"
   Last-Modified: Mon, 15 Feb 2024 12:00:00 GMT
   ```

   - 资源在 `max-age` 期间直接使用缓存。
   - 过期后，再走 `ETag` 和 `Last-Modified` 协商缓存。

2. **避免缓存（开发模式）**

   ```http
   Cache-Control: no-cache
   ```

   - 每次都**发送请求**，但可使用 `304 Not Modified` 让浏览器决定是否使用缓存。

3. **完全禁用缓存**

   ```http
   Cache-Control: no-store
   ```

   - **每次都重新下载**，适用于**安全数据**（如用户信息、支付页面）。

## **6. 结论**

- **强制缓存（`Cache-Control: max-age`）** 优先级更高，不向服务器请求，直接使用缓存。
- **协商缓存（`ETag` / `Last-Modified`）** 只有在强制缓存失效后才生效。
- **建议结合使用 `Cache-Control`、`ETag` 和 `Last-Modified`** 以实现最佳性能和数据一致性。

在前端开发中，合理配置缓存可以显著提高页面加载速度，降低服务器负载 🚀。

# Nginx 缓存

nginx 的 **proxy_cache** 主要用于缓存后端服务器的响应内容，从而降低后端服务器的负载、提高访问响应速度，并节约带宽资源。通过将经常请求的数据存储在本地缓存中，当有相同请求时，nginx 可以直接返回缓存内容，而无需再次转发请求到后端服务器。

下面简要介绍其作用及配置方法：

### 1. 主要作用

- **提升性能与响应速度**
   通过缓存静态文件或动态生成的内容，减少后端服务器处理请求的次数，从而提高整体访问速度。
- **降低后端负载**
   缓存机制可以有效减少后端服务器的请求压力，使服务器资源得到更合理的分配和利用。
- **节省网络带宽**
   对于高并发访问场景，通过返回缓存内容，可减少重复的数据传输，节省网络带宽。
- **改善用户体验**
   通过减少响应延迟，用户可以获得更快的访问体验。

### 2. 配置方法

nginx 的 proxy_cache 配置通常涉及以下几个步骤：

#### (1) 定义缓存路径和缓存区

在 `http` 块中使用 `proxy_cache_path` 指令定义缓存文件存储路径、缓存键区名称、最大缓存大小、缓存过期时间等参数。例如：

```nginx
http {
    # 定义缓存存储路径及参数
    proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m max_size=1g inactive=60m use_temp_path=off;

    ...
}
```

- **/data/nginx/cache**：缓存文件存放的目录。
- **levels=1:2**：设置子目录层级结构，有利于文件管理。
- **keys_zone=my_cache:10m**：定义一个名为 `my_cache` 的缓存区域，并分配 10MB 内存用于存储缓存键。
- **max_size=1g**：缓存目录允许占用的最大磁盘空间。
- **inactive=60m**：未被访问的缓存项在 60 分钟后失效。
- **use_temp_path=off**：直接写入目标目录，避免使用临时目录。

#### (2) 在服务器或 location 块中启用缓存

在对应的 `server` 或 `location` 块中使用 `proxy_cache` 指令启用缓存功能，同时配置 `proxy_pass`、缓存有效时间等。例如：

```nginx
server {
    listen 80;
    server_name example.com;

    location / {
        # 将请求转发到后端服务器
        proxy_pass http://backend;
        
        # 启用缓存，并指定缓存区域名称
        proxy_cache my_cache;
        
        # 设置缓存有效时间（根据响应状态码）
        proxy_cache_valid 200 302 10m;
        proxy_cache_valid 404 1m;
        
        # 添加自定义响应头，显示缓存状态（MISS, HIT, EXPIRED, BYPASS）
        add_header X-Cache-Status $upstream_cache_status;
    }
}
```

- **proxy_pass**：将请求转发到后端服务器地址。
- **proxy_cache**：指定使用前面定义的 `my_cache` 缓存区域。
- **proxy_cache_valid**：为不同的 HTTP 状态码设置缓存时间。
- **add_header**：通过自定义响应头查看缓存状态，便于调试与监控。

#### (3) 其他常用配置

- **proxy_cache_key**：用于定义缓存键。默认情况下，nginx 会使用请求的 URL 作为缓存键，但也可以通过 `proxy_cache_key` 指令自定义，例如加入请求头、参数等信息。
- **proxy_ignore_headers**：有时后端会返回禁止缓存的头部信息，可以使用此指令忽略特定头部以实现缓存需求。
- **proxy_cache_lock**：在高并发场景下，可以防止多个请求同时发起到后端服务器，从而实现缓存锁定。

### 总结

nginx 的 proxy_cache 是一种高效的缓存机制，通过配置缓存路径、缓存区域以及各类缓存策略，可以显著提高网站性能，减轻后端服务器压力。在实际应用中，需要根据具体业务场景合理调整各项参数，以达到最佳效果。

以上就是 nginx proxy_cache 的主要作用及基本配置方法。